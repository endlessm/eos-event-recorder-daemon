#!/usr/bin/python3

import argparse
import os
import re
import shutil
import subprocess
import sys
import time
import tempfile

from distutils.version import StrictVersion


def get_eos_version():
    f = open("/etc/os-release")

    for line in f.readlines():
        key, value = line.split("=")
        if key == "ID":
            distro = value.rstrip('\n').strip('"')
        if key == "VERSION_ID":
            version = value.rstrip('\n').strip('"')

    if distro == "endless":
        return version
    return None


class OfflineMetrics():
    def __init__(self, storage_root):
        self.metrics_cache_dir = '/var/cache/metrics'
        self.tracking_id_path = '/etc/metrics/tracking-id'
        self.machine_id_path = '/etc/machine-id'
        self.systemd_service = 'eos-metrics-event-recorder.service'
        self.metrics_config_file = '/etc/metrics/eos-metrics-permissions.conf'
        self.metrics_proc_name = 'eos-metrics-event-recorder'
        self.storage_root = storage_root
        self.storage_dir = os.path.join(self.storage_root, 'eos-metrics-data')
        if os.path.exists(self.tracking_id_path):
            self.metrics_id = self.tracking_id_path
        else:
            self.metrics_id = self.machine_id_path


    def metrics_proc_exists(self):
        ps = subprocess.Popen("ps ax -o pid= -o args= ", shell=True, stdout=subprocess.PIPE)
        ps_pid = ps.pid
        output = ps.stdout.read()
        ps.stdout.close()
        ps.wait()

        for line in str(output).split('\n'):
            res = re.findall("(\d+) (.*)", line)
            if res:
                pid = int(res[0][0])
                if self.metrics_proc_name in res[0][1] and pid != os.getpid() and pid != ps_pid:
                    return True
        return False

    def metrics_unit(self, operation):
        p = subprocess.run(['systemctl', operation, '--quiet ',
            self.systemd_service])
        return (p.returncode == 0)


class OfflineMetricsUploader(OfflineMetrics):
    def __init__(self, storage_root):
        super().__init__(storage_root)
        self.offline_tmp_metrics_dir = ''

    def copy_metrics_data_and_upload(self):
        srcdir = self.storage_dir
        if not os.path.exists(srcdir):
            print(f"No metrics data found in {srcdir}, nothing to do.")
            sys.exit(0)

        daemon_was_running = self.metrics_unit('is-active')
        self.metrics_unit('stop')

        for machine_dir in os.listdir(srcdir):
            self.offline_tmp_metrics_dir = tempfile.mkdtemp()
            machine_path = os.path.join(srcdir, machine_dir)
            for file in os.listdir(machine_path):
                shutil.copy(os.path.join(machine_path, file), self.offline_tmp_metrics_dir)
            subprocess.check_output(['sudo', 'chown', '-R', 'metrics:metrics', self.offline_tmp_metrics_dir])
            persistent_cache_dir_arg = '--persistent-cache-directory=' + self.offline_tmp_metrics_dir
            tracking_id_path_arg = '--tracking-id-file-path=' + self.offline_tmp_metrics_dir + '/tracking-id'
            self.daemon = subprocess.Popen(['sudo', '-u', 'metrics', '/lib/eos-event-recorder-daemon/eos-metrics-event-recorder', persistent_cache_dir_arg, tracking_id_path_arg], stderr=subprocess.DEVNULL)

            timeout = 0
            while timeout < 5:
                time.sleep(1)
                if self.metrics_proc_exists():
                    break
                timeout = timeout + 1
            if timeout >= 5:
                print('Fail to launch eos-metrics-event-recorder')
                sys.exit()

            upload = subprocess.run(['/usr/bin/eos-upload-metrics'], stdout=subprocess.DEVNULL)
            if (upload.returncode != 0):
                print('Upload Fail.')
                sys.exit()
            else:
                print("Upload successfully for tracking id " + machine_dir)

            subprocess.check_output(['sudo', 'killall', '/lib/eos-event-recorder-daemon/eos-metrics-event-recorder'])
            subprocess.check_output(['sudo', 'rm', '-rf', self.offline_tmp_metrics_dir])

    def __del__(self):
        '''
        Remove temporary cache data, kill the eos-metrics-event-recorder.
        And restart the service
        '''
        if os.path.exists(self.offline_tmp_metrics_dir):
            subprocess.check_output(['sudo', 'rm', '-rf', self.offline_tmp_metrics_dir])
        if self.metrics_proc_exists():
            subprocess.check_output(['sudo', 'killall', '/lib/eos-event-recorder-daemon/eos-metrics-event-recorder'])
        if daemon_was_running:
            self.metrics_unit('start')


class OfflineMetricsCollector(OfflineMetrics):
    def __init__(self, storage_root):
        super().__init__(storage_root)
        self.machine_dir = None

    def get_usbdisk_free_space(self):
        disk_usage = shutil.disk_usage(self.storage_root)
        return disk_usage.free

    def calculate_metrics_data_size(self):
        size = os.path.getsize(self.metrics_cache_dir)
        if os.path.exists(self.tracking_id_path):
            size += os.path.getsize(self.tracking_id_path)
        elif os.path.exists(self.machine_id_path):
            size += os.path.getsize(self.machine_id_path)
        return size

    def create_machine_dir(self):
        if not os.path.exists(self.storage_dir):
            os.mkdir(self.storage_dir)

        f = open(self.metrics_id_path)
        self.machine_dir = os.path.join(self.storage_dir, f.read(32))
        f.close()

        if os.path.exists(self.machine_dir):
            msg = (
                f"Looks like metrics data for this machine exists in the "
                f"target storage device. Please use a different target device "
                f"or manually remove{self.machine_dir}. Aborting."
            )
            sys.exit(msg)
        os.mkdir(self.machine_dir)

    def copy_metrics_data(self):
        files = [
            'boot_offset_metafile', 'local_version_file', 'network_send_file',
            'variants.dat', 'variants.dat.metadata'
        ]
        # shutil.copy tries to maintain the file mode, and some files have the
        # sticky bit set, which is not supported by FAT32, so we use
        # shutil.copyfile which ignores metadata.
        for f in files:
            src = os.path.join(self.metrics_cache_dir, f)
            dst = os.path.join(self.machine_dir, f)
            if os.path.exists(src):
                shutil.copyfile(src, dst)
        shutil.copyfile(self.metrics_id,
            os.path.join(self.machine_dir, 'tracking-id'))

    def reset_metrics_data(self):
        files = ['variants.dat', 'variants.dat.metadata']
        for f in files:
            target = os.path.join(self.metrics_cache_dir, f)
            subprocess.run(['rm', '-f', target])

    def collect_metrics(self):
        self.create_machine_dir()
        daemon_was_running = self.metrics_unit('is-active')
        self.metrics_unit('stop')
        self.copy_metrics_data()
        self.reset_metrics_data()
        if daemon_was_running:
            self.metrics_unit('start')


def collect(storage_root):
    collector = OfflineMetricsCollector(storage_root)
    free_space = collector.get_usbdisk_free_space()
    data_size = collector.calculate_metrics_data_size()
    if free_space < data_size:
        msg = (
            f"Insufficient free space ({free_space} bytes) for metrics "
            f"data size ({data_size} bytes), aborting."
        )
        sys.exit(msg)
    collector.collect_metrics()
    print("Metrics data successfully collected ({data_size} bytes)")


def upload(storage_root):
    eos_version = get_eos_version()
    if eos_version is None:
        sys.exit("This program only works on Endless OS, exiting.")
    if StrictVersion(eos_version) < StrictVersion("3.9.0"):
        msg = (
            f"Uploading metrics collected from other machines requires "
            f"EOS >= 3.9.0, and {eos_version} was detected, exiting."
        )
        sys.exit(msg)

    uploader = OfflineMetricsUploader(storage_root)
    uploader.copy_metrics_data_and_upload()
    shutil.rmtree(self.storage_dir)
    print("Metrics data successfully uploaded")


def main():
    desc = """
    Offline Metrics Collector for Endless OS.

    This program is designed to be executed from a removable storage device,
    like a USB flash drive. It supports two actions, 'collect' and 'upload'.

    The 'collect' action will extract any existing metrics from the system
    where it is running and copy it to the removable storage device that it is
    running from.

    The 'upload' action will upload all extracted metrics data located in the
    removable storage device that it is running from to the Endless' metrics
    servers."""
    epil = "The 'upload' action requires Endless OS 3.9.0 or newer."

    parser = argparse.ArgumentParser(description=desc, epilog=epil,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('action', nargs='?', choices=['collect', 'upload'],
        default='collect', help='action to be performed (default: %(default)s)')
    args = parser.parse_args()

    storage_root = sys.path[0]
    if args.action == "collect":
        collect(storage_root)
    elif args.action == "upload":
        upload(storage_root)


if __name__ == '__main__':
    main()
