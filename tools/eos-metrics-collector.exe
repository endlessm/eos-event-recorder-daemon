#!/usr/bin/python3

import argparse
import os
import re
import shutil
import subprocess
import sys
import time
import tempfile

from distutils.version import StrictVersion


def get_eos_version():
    f = open("/etc/os-release")

    for line in f.readlines():
        key, value = line.split("=")
        if key == "ID":
            distro = value.rstrip('\n').strip('"')
        if key == "VERSION_ID":
            version = value.rstrip('\n').strip('"')

    if distro == "endless":
        return version
    return None


class OfflineMetrics():
    def __init__(self, storage_root):
        self.metrics_cache_dir = '/var/cache/metrics'
        self.tracking_id_path = '/etc/metrics/tracking-id'
        self.machine_id_path = '/etc/machine-id'
        self.systemd_service = 'eos-metrics-event-recorder.service'
        self.metrics_config_file = '/etc/metrics/eos-metrics-permissions.conf'
        self.metrics_proc_name = 'eos-metrics-event-recorder'
        self.storage_root = storage_root
        self.storage_dir = os.path.join(self.storage_root, 'eos-metrics-data')
        if os.path.exists(self.tracking_id_path):
            self.metrics_id = self.tracking_id_path
        else:
            self.metrics_id = self.machine_id_path

    def metrics_proc_exists(self):
        ps = subprocess.Popen("ps ax -o pid= -o args= ", shell=True, stdout=subprocess.PIPE)
        ps_pid = ps.pid
        output = ps.stdout.read()
        ps.stdout.close()
        ps.wait()

        for line in str(output).split('\n'):
            res = re.findall("(\d+) (.*)", line)
            if res:
                pid = int(res[0][0])
                if self.metrics_proc_name in res[0][1] and pid != os.getpid() and pid != ps_pid:
                    return True
        return False

    def metrics_unit(self, operation):
        # TODO: the metrics daemon is also D-Bus activatable, so on stop we
        # should also do something to prevent it being started over D-Bus.
        p = subprocess.run(['systemctl', operation, '--quiet ',
                            self.systemd_service])
        return (p.returncode == 0)


class OfflineMetricsUploader(OfflineMetrics):
    def __init__(self, storage_root):
        super().__init__(storage_root)
        self.bin_dir = "/usr/lib/eos-event-recorder-daemon"
        self.bin_name = "eos-metrics-event-recorder"
        self.bin_path = os.path.join(self.bin_dir, self.bin_name)
        self.up_trigger_bin = "eos-upload-metrics"
        self.tmpdir = ''
        self.daemon = None
        self.unit_was_running = False

    def cleanup(self):
        if self.daemon is not None:
            self.daemon.terminate()
            self.daemon = None
        if os.path.exists(self.tmpdir):
            shutil.rmtree(self.tmpdir)
        if self.unit_was_running:
            self.metrics_unit('start')

    def copy_metrics_data_and_upload(self):
        if not os.path.exists(self.storage_dir):
            msg = (
                f"No metrics data found in {self.storage_dir}, nothing to do."
            )
            print(msg)
            sys.exit(0)

        self.unit_was_running = self.metrics_unit('is-active')
        self.metrics_unit('stop')

        self.tmpdir = tempfile.mkdtemp()
        for tracking_id in os.listdir(self.storage_dir):
            machine_srcdir = os.path.join(self.storage_dir, tracking_id)
            machine_dstdir = os.path.join(self.tmpdir, tracking_id)

            for f in os.listdir(machine_srcdir):
                src = os.path.join(machine_srcdir, f)
                dst = os.path.join(machine_dstdir, f)
                shutil.copyfile(src, dst)
            subprocess.run(['chown', '-R', 'metrics:metrics', machine_dstdir])

            dir_arg = f"--persistent-cache-directory={machine_dstdir}"
            id_arg = f"--tracking-id-file-path={machine_dstdir}/tracking-id"
            self.daemon = subprocess.Popen(
                ['sudo', '-u', 'metrics', self.bin_path, dir_arg, id_arg],
                stdin=subprocess.DEVNULL, stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL)

            timeout = 0
            while timeout < 5:
                time.sleep(1)
                if self.metrics_proc_exists():
                    break
                timeout = timeout + 1
            if timeout >= 5:
                self.cleanup()
                sys.exit('Failed to launch {self.bin_name}, aborting.')

            up_trigger = subprocess.run(self.up_trigger_bin,
                                        stdout=subprocess.DEVNULL)
            if up_trigger.returncode != 0:
                msg = (
                    "Failed to upload metrics, {self.up_trigger_bin} failed "
                    "with status {up_trigger.returncode}. Aborting."
                )
                self.cleanup()
                sys.exit(msg)

            self.daemon.terminate()
            self.daemon = None
            shutil.rmtree(machine_dstdir)
            print("Successfully uploaded metrics for {tracking_id}")
        self.cleanup()


class OfflineMetricsCollector(OfflineMetrics):
    def __init__(self, storage_root):
        super().__init__(storage_root)
        self.machine_dir = None

    def get_usbdisk_free_space(self):
        disk_usage = shutil.disk_usage(self.storage_root)
        return disk_usage.free

    def calculate_metrics_data_size(self):
        size = os.path.getsize(self.metrics_cache_dir)
        if os.path.exists(self.tracking_id_path):
            size += os.path.getsize(self.tracking_id_path)
        elif os.path.exists(self.machine_id_path):
            size += os.path.getsize(self.machine_id_path)
        return size

    def create_machine_dir(self):
        if not os.path.exists(self.storage_dir):
            os.mkdir(self.storage_dir)

        f = open(self.metrics_id_path)
        self.machine_dir = os.path.join(self.storage_dir, f.read(32))
        f.close()

        if os.path.exists(self.machine_dir):
            msg = (
                f"Looks like metrics data for this machine exists in the "
                f"target storage device. Please use a different target device "
                f"or manually remove{self.machine_dir}. Aborting."
            )
            sys.exit(msg)
        os.mkdir(self.machine_dir)

    def copy_metrics_data(self):
        files = [
            'boot_offset_metafile', 'local_version_file', 'network_send_file',
            'variants.dat', 'variants.dat.metadata'
        ]
        # shutil.copy tries to maintain the file mode, and some files have the
        # sticky bit set, which is not supported by FAT32, so we use
        # shutil.copyfile which ignores metadata.
        for f in files:
            src = os.path.join(self.metrics_cache_dir, f)
            dst = os.path.join(self.machine_dir, f)
            if os.path.exists(src):
                shutil.copyfile(src, dst)
        shutil.copyfile(self.metrics_id,
                        os.path.join(self.machine_dir, 'tracking-id'))

    def reset_metrics_data(self):
        files = ['variants.dat', 'variants.dat.metadata']
        for f in files:
            target = os.path.join(self.metrics_cache_dir, f)
            subprocess.run(['rm', '-f', target])

    def collect_metrics(self):
        self.create_machine_dir()
        unit_was_running = self.metrics_unit('is-active')
        self.metrics_unit('stop')
        self.copy_metrics_data()
        self.reset_metrics_data()
        if unit_was_running:
            self.metrics_unit('start')


def collect(storage_root):
    collector = OfflineMetricsCollector(storage_root)
    free_space = collector.get_usbdisk_free_space()
    data_size = collector.calculate_metrics_data_size()
    if free_space < data_size:
        msg = (
            f"Insufficient free space ({free_space} bytes) for metrics "
            f"data size ({data_size} bytes), aborting."
        )
        sys.exit(msg)
    collector.collect_metrics()
    print("Metrics data successfully collected ({data_size} bytes)")


def upload(storage_root):
    eos_version = get_eos_version()
    if eos_version is None:
        sys.exit("This program only works on Endless OS, exiting.")
    if StrictVersion(eos_version) < StrictVersion("3.9.0"):
        msg = (
            f"Uploading metrics collected from other machines requires "
            f"EOS >= 3.9.0, and {eos_version} was detected, exiting."
        )
        sys.exit(msg)

    uploader = OfflineMetricsUploader(storage_root)
    uploader.copy_metrics_data_and_upload()
    shutil.rmtree(storage_root)
    print("Metrics data successfully uploaded")


def main():
    desc = """
    Offline Metrics Collector for Endless OS.

    This program is designed to be executed from a removable storage device,
    like a USB flash drive. It supports two actions, 'collect' and 'upload'.

    The 'collect' action will extract any existing metrics from the system
    where it is running and copy it to the removable storage device that it is
    running from.

    The 'upload' action will upload all extracted metrics data located in the
    removable storage device that it is running from to the Endless' metrics
    servers."""
    epil = "The 'upload' action requires Endless OS 3.9.0 or newer."

    parser = argparse.ArgumentParser(
        description=desc, epilog=epil,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument('action', nargs='?', choices=['collect', 'upload'],
                        default='collect',
                        help='action to be performed (default: %(default)s)')
    args = parser.parse_args()

    storage_root = sys.path[0]
    if args.action == "collect":
        collect(storage_root)
    elif args.action == "upload":
        upload(storage_root)


if __name__ == '__main__':
    main()
